---
layout: post
title: The Oddities of Go (compared to other programming languages)
tags: [go,programming]
---

I've been learning Go recently so I thought it'd be useful to write a bit about 
what has been new for me (and sometimes even strange).
Most of my prior experience has been Python, Javascript, C, C++, and Java,
so there are some things about Go that are very different from all of those.

For now, I'll make a skeleton list and fill out each section when I have time.

## Hello World in Go

To get you familiar with the syntax of Go, here's an example program that prints 
"Hello World!"

```go
package main

import "fmt"

func main() {
  fmt.Println("Hello World!")
}
```

## Packages

Go is organized into packages. Every go file has to belong to a package.
If you're wondering, this is much less irksome than Java's requirement that everything belong to a class.
To say what package a Go file is in, you put `package <packagename>` at the top.
Every package is confined to a directory, meaning you can't have .go files with different package names in the same directory.
The main package is called `main`, which is the oddest of all.

That's all I'm going to say for now about packages.
Nothing too odd there, but it's helpful background for the next section. 

## Private/public

Many languages have some kind of way to specify whether a variable, function, variable, or class
is public or private (or protected, etc).
In C++ and Java, you use key words like `private` and `public` to make this distinction. 
Python typically uses underscores to signify private, or at least you shouldn't rely on it as part of
its public API, but it's not enforced by the language. 
In Go, "private" things start with a lowercase letter, while "public" things start with uppercase letters.
A package only exports the identifiers (variables, functions, etc) that start with an uppercase letter.
All identifiers declared in a package are available throughout that package, whether they start with upper or lowercase.

Let's do a little example.

Here are the contents of `example1.go`:

```go
package example

var myPrivateThing = "asdf"

var MyPublicThing = "jkl;"
```

In this case, `myPrivateThing` is available throughout `package example`.
If I had another file `example2.go`, I could access everything defined in `example1.go`.

```go
package example

import "fmt"

func printSomething() {
  fmt.Println(MyPublicThing) // success
  fmt.Println(myPrivateThing) // success
}
```

`MyPublicThing` could be accessed from any package that imports `package example`, but `myPrivateThing` cannot.
Here's an example of that in a theoretical `main.go`:

```go
package main

import (
  "fmt"
  "some/path/to/example"
)

func main() {
  fmt.Println(example.MyPublicThing) // succeeds
  fmt.Println(example.myPrivateThing) // error
}
```

## Naked returns and named return parameters

Coming soon :smile:
